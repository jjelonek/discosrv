// Copyright (C) 2014 Jakob Borg and Contributors (see the CONTRIBUTORS file).
// All rights reserved. Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

// ************************************************************
// This file is automatically generated by genxdr. Do not edit.
// ************************************************************

package discosrv

import (
	"bytes"
	"io"

	"github.com/calmh/xdr"
)

/*

address Structure:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         Length of ip                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                     ip (variable length)                      \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            0x0000             |             port              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                        seen (64 bits)                         +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


struct address {
	opaque ip<>;
	unsigned int port;
	hyper seen;
}

*/

func (o address) EncodeXDR(w io.Writer) (int, error) {
	var xw = xdr.NewWriter(w)
	return o.encodeXDR(xw)
}

func (o address) MarshalXDR() []byte {
	return o.AppendXDR(make([]byte, 0, 128))
}

func (o address) AppendXDR(bs []byte) []byte {
	var aw = xdr.AppendWriter(bs)
	var xw = xdr.NewWriter(&aw)
	o.encodeXDR(xw)
	return []byte(aw)
}

func (o address) encodeXDR(xw *xdr.Writer) (int, error) {
	xw.WriteBytes(o.ip)
	xw.WriteUint16(o.port)
	xw.WriteUint64(uint64(o.seen))
	return xw.Tot(), xw.Error()
}

func (o *address) DecodeXDR(r io.Reader) error {
	xr := xdr.NewReader(r)
	return o.decodeXDR(xr)
}

func (o *address) UnmarshalXDR(bs []byte) error {
	var br = bytes.NewReader(bs)
	var xr = xdr.NewReader(br)
	return o.decodeXDR(xr)
}

func (o *address) decodeXDR(xr *xdr.Reader) error {
	o.ip = xr.ReadBytes()
	o.port = xr.ReadUint16()
	o.seen = int64(xr.ReadUint64())
	return xr.Error()
}

/*

addressList Structure:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Number of addresses                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                Zero or more address Structures                \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


struct addressList {
	address addresses<>;
}

*/

func (o addressList) EncodeXDR(w io.Writer) (int, error) {
	var xw = xdr.NewWriter(w)
	return o.encodeXDR(xw)
}

func (o addressList) MarshalXDR() []byte {
	return o.AppendXDR(make([]byte, 0, 128))
}

func (o addressList) AppendXDR(bs []byte) []byte {
	var aw = xdr.AppendWriter(bs)
	var xw = xdr.NewWriter(&aw)
	o.encodeXDR(xw)
	return []byte(aw)
}

func (o addressList) encodeXDR(xw *xdr.Writer) (int, error) {
	xw.WriteUint32(uint32(len(o.addresses)))
	for i := range o.addresses {
		o.addresses[i].encodeXDR(xw)
	}
	return xw.Tot(), xw.Error()
}

func (o *addressList) DecodeXDR(r io.Reader) error {
	xr := xdr.NewReader(r)
	return o.decodeXDR(xr)
}

func (o *addressList) UnmarshalXDR(bs []byte) error {
	var br = bytes.NewReader(bs)
	var xr = xdr.NewReader(br)
	return o.decodeXDR(xr)
}

func (o *addressList) decodeXDR(xr *xdr.Reader) error {
	_addressesSize := int(xr.ReadUint32())
	o.addresses = make([]address, _addressesSize)
	for i := range o.addresses {
		(&o.addresses[i]).decodeXDR(xr)
	}
	return xr.Error()
}
